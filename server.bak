// server.js — минимальный Express-сервер для Mini App + iiko-заготовки
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const crypto = require('crypto');
const axios = require('axios');
const { Low } = require('lowdb');
const { JSONFile } = require('lowdb/node');
const { nanoid } = require('nanoid');

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('public')); // отдаём фронт из /public

// простая JSON-"база"
const db = new Low(new JSONFile('./db.json'), { users: {}, orders: [], 
menu: { categories: [], products: [] } });
await db.read();

// валидация Telegram initData (HMAC по правилу WebAppData)
function validateInitData(initData) {
  if (!initData) return { ok: false, reason: 'empty' };
  const urlParams = new URLSearchParams(initData);
  const hash = urlParams.get('hash');
  urlParams.delete('hash');
  const data = [];
  for (const [k, v] of urlParams.entries()) data.push(`${k}=${v}`);
  data.sort();
  const dataCheckString = data.join('\n');
  const secretKey = crypto.createHmac('sha256', 'WebAppData')
    .update(process.env.BOT_TOKEN || 'MISSING_BOT_TOKEN').digest();
  const hmac = crypto.createHmac('sha256', 
secretKey).update(dataCheckString).digest('hex');
  return { ok: hmac === hash, reason: hmac === hash ? null : 
'hash_mismatch' };
}

// iiko токен (пока заглушка: можно работать и без iiko)
let iikoToken = null;
let iikoTokenExp = 0;

async function getIikoToken() {
  const now = Date.now();
  if (iikoToken && now < iikoTokenExp) return iikoToken;
  if (!process.env.IIKO_API_LOGIN || !process.env.IIKO_API_BASE) return 
null;
  const resp = await 
axios.post(`${process.env.IIKO_API_BASE}/api/1/access_token`, {
    apiLogin: process.env.IIKO_API_LOGIN
  });
  iikoToken = resp.data.token;
  iikoTokenExp = now + 10 * 60 * 1000; // ~10 минут
  return iikoToken;
}

async function fetchIikoMenu() {
  try {
    const token = await getIikoToken();
    if (!token) throw new Error('No iiko token (offline)');

    const resp = await 
axios.post(`${process.env.IIKO_API_BASE}/api/1/nomenclature`, {
      organizationId: process.env.IIKO_ORG_ID
    }, { headers: { Authorization: `Bearer ${token}` } });

    const categories = (resp.data.groups || []).map(g => ({ id: g.id, 
name: g.name }));
    const products = (resp.data.products || [])
      .filter(p => !p.isDeleted)
      .map(p => ({
        id: p.id,
        name: p.name,
        price: Math.round((p.price || 0) * 100) / 100,
        categoryId: p.parentGroup || null,
      }));

    const catById = Object.fromEntries(categories.map(c => [c.id, 
c.name]));
    products.forEach(p => p.categoryName = catById[p.categoryId] || 
'Прочее');

    db.data.menu = { categories, products };
    await db.write();
  } catch (e) {
    console.log('iiko menu load failed, using fallback:', e.message);
  }
}

// подгрузим меню при старте (если нет — будет FALLBACK)
await fetchIikoMenu();

const FALLBACK = {
  categories: [{ id: 'c1', name: 'Напитки' }, { id: 'c2', name: 'Закуски' 
}],
  products: [
    { id: 'p1', name: 'Лагер 0.5', price: 250, categoryId: 'c1', 
categoryName: 'Напитки' },
    { id: 'p2', name: 'IPA 0.5', price: 320, categoryId: 'c1', 
categoryName: 'Напитки' },
    { id: 'p3', name: 'Начос', price: 290, categoryId: 'c2', categoryName: 
'Закуски' },
  ]
};

// API: bootstrap — проверяем initData и отдаём меню/заказы
app.post('/api/bootstrap', async (req, res) => {
  const { initData } = req.body || {};
  let user = null;

  if (initData) {
    const v = validateInitData(initData);
    if (!v.ok) return res.status(401).json({ error: 'initData invalid: ' + 
v.reason });
    const params = new URLSearchParams(initData);
    const userRaw = params.get('user');
    if (userRaw) user = JSON.parse(userRaw);
    if (user) {
      db.data.users[user.id] = db.data.users[user.id] || { id: user.id, 
first_name: user.first_name };
      await db.write();
    }
  }

  const menu = db.data.menu?.products?.length ? db.data.menu : FALLBACK;
  const orders = user ? db.data.orders.filter(o => o.userId === user.id) : 
[];
  res.json({ user, categories: menu.categories, products: menu.products, 
orders });
});

// API: получить последние заказы (упрощённо)
app.get('/api/orders', (req, res) => {
  res.json({ orders: db.data.orders.slice(-20) });
});

// API: создать заказ
app.post('/api/orders', async (req, res) => {
  try {
    const { initData, items, delivery } = req.body || {};
    const v = validateInitData(initData);
    if (!v.ok) return res.status(401).json({ ok:false, error:'initData 
invalid' });

    const params = new URLSearchParams(initData);
    const user = JSON.parse(params.get('user') || '{}');

    if (!Array.isArray(items) || !items.length) {
      return res.json({ ok:false, error:'Пустая корзина' });
    }

    const menu = db.data.menu?.products?.length ? db.data.menu : FALLBACK;
    const byId = Object.fromEntries(menu.products.map(p => [p.id, p]));
    let subtotal = 0;
    const lines = [];
    for (const it of items) {
      const prod = byId[it.id];
      if (!prod) return res.json({ ok:false, error:`Товар не найден: 
${it.id}` });
      const qty = Math.max(1, parseInt(it.qty || 1, 10));
      subtotal += prod.price * qty;
      lines.push({ id: prod.id, name: prod.name, price: prod.price, qty 
});
    }

    const fee = (delivery?.method === 'courier')
      ? (delivery?.zone === 'zone2' ? 200 : delivery?.zone === 'zone1' ? 
100 : 0)
      : 0;

    const total = Math.round((subtotal + fee) * 100) / 100;

    const orderNumber = nanoid(6);
    const record = {
      id: nanoid(),
      number: orderNumber,
      userId: user?.id || null,
      items: lines,
      delivery: { ...delivery, fee },
      subtotal, total,
      status: 'created',
      createdAt: Date.now()
    };
    db.data.orders.push(record);
    await db.write();

    res.json({ ok:true, orderNumber, total });
  } catch (e) {
    console.error(e);
    res.json({ ok:false, error:e.message });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log('Server on http://localhost:' + PORT);
});
